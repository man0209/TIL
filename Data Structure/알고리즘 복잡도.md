# 알고리즘 복잡도 계산 항목
- 시간 복잡도 : 알고리즘 실행 속도
- 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈 (예전 메모리가 작았을 때)(변수가 몇 개가 선언되는지 등등)
- 요즘은 하드웨어가 많이 좋아져서 공간 복잡도는 거의 보지 않고 시간 복잡도를 더 중요하게 생각한다.
- 따라서 시간 복잡도를 꼭 이해하고 계산할 수 있어야 한다.
- 시간 복잡도는? 반복문이 지배한다!!!
- 입력의 크기가 커지면 커질수록 반복문이 알고리즘 수행 시간을 지배한다.

# 알고리즘 성능 표기법
- Big O (빅-오) 표기법 : O(N)
  - 알고리즘 최악의 실행 시간을 표기
  - 가장 많이/일반적으로 사용함
  - 아무리 최악의 상황이라도, 이 정도의 성능은 보장한다는 의미이기 때문
 
- Ω(오메가) 표기법 : Ω(N)
  - 오메가 표기법은 알고리즘 최상의 실행 시간을 표기

- θ(세타) 표기법 : θ(N)
  - 오메가 표기법은 알고리즘 평균 실행 시간을 표기
- 시간 복잡도 계산은 반복문이 핵심 요소임을 인지하고, 계산 표기는 최상, 평균, 최악 중, 최악의 시간인 Big-O 표기법을 중심으로 익히면 된다. 

# Big O 표기법
- O(입력)
  - 입력 n에 따라 결정되는 시간 복잡도 함수
  - O(1), O(logn), O(n), O(nlogn), O(n^2), O(n!)등으로 표기함
  - 입력 n 의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음
    - `O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!)`
      - 참고 : log n 의 베이스는 2 - log2(밑)n
- 단순하게 입력 n에 따라 몇번 실행이 되는지를 계산하면 된다.
  - 표현식에 가장 큰 영향을 미치는 n의 단위로 표기합니다.
  - n이 1이든 100이든 1000이든 10000이든 실행을
- O(1) - 상수 시간 (Constant time)
  - 입력 크기 (n)에 상관없이 일정한 연산을 수행하면 시간복잡도는 O(1) 입니다.
  ```
  void func (int n){
    printf("%d\n", n);
   }
   ```
   - 위 알고리즘은 n에 상관없이 한 번의 연산만 수행하기 때문에 시간 복잡도는 다음과 같습니다.
   - T(n) = O(1)

- O(logN) - 로그 시간 (Logarithmic time)
  - 입력 크기(N)가 커질 때 연산 횟수가 logN에 비례해서 증가하면 시간 복잡도는 O(logN) 입니다.
  ```
  for(i = 1; i <= n; i * 2) {
    ...
    }
  ```
  - 위 알고리즘은 i 값이 반복할 때마다 2배씩 증가합니다. 이것을 k번 반복했을 때 다음과 같습니다.
  - 2^k = N 이 되고 반복문이 종료됩니다. 양쪽에 로그를 취하면 다음과 같습니다.
  - ![image](https://user-images.githubusercontent.com/69157076/173558080-890e8033-1b2c-4999-91ef-abd5185f6f58.png)
  - k 는 수행 횟수이기 때문에 시간 복잡도는 다음과 같습니다.
  - ![image](https://user-images.githubusercontent.com/69157076/173558151-0c72d9de-6641-43cf-8922-5b2ef93ed967.png)

- O(n) -선형 시간 (Linear time)
  - 입력 크기(n)가 커질 때 연산 횟수가 n에 비례해서 증가하면 시간 복잡도는 O(n) 입니다.
  ```
  for (i = 0; i < n; i++) {
  ...
  }
  ```
  - 위 알고리즘은 n 만큼 반복문을 수행합니다.
  - n에 값에 비례해서 연산수가 선형적으로 증가하기 때문에 시간 복잡도는 다음과 같습니다.
  - ![image](https://user-images.githubusercontent.com/69157076/173558732-2854d608-3924-4bd7-a894-91e84f434b8e.png)

- ![image](https://user-images.githubusercontent.com/69157076/173558771-a25e28d3-5ce2-460f-9d5a-90a6d98d2ef9.png)
  - 입력 크기(n)가 커질 때 연산 횟수가 n^2에 비례해서 증가하면 시간 복잡도는 O(n^2)입니다.
  ```
  for(i = 0; i < n; i++){
    for(j = 0; j < n; j++) {
      ...
      }
    }
  ```
  - 위 알고리즘은 for 문이 중첩되어 있기 때문에 n^2에 비례해서 연산수가 증가합니다.
  - 시간 복잡도는 다음과 같습니다.
  - ![image](https://user-images.githubusercontent.com/69157076/173559083-776bfe83-fc65-43cc-928a-7e0b989cb1ac.png)

- ![image](https://user-images.githubusercontent.com/69157076/173559109-73acc6b0-9e40-490b-b587-7e8afa6ed0fe.png)
  - 입력 크기가 커질 때 연산수가 2^n에 비례해서 증가하면 시간 복잡도는 O(2^n)입니다.
  ```
  int func (int n){
    if (n <= 1)
      return n;
     return func(n - 1) + func(n - 2);
   }
  ```
  - 위 알고리즘은 피보나치 수를 구하는 알고리즘입니다.
  - 한번 함수를 호출할 때마다 두 번씩 재귀로 함수를 호출하기 때문에 2^n에 비례해서 연산수가 증가합니다.
  - 시간 복잡도는 다음과 같습니다.
  - ![image](https://user-images.githubusercontent.com/69157076/173559348-f9b3a3dd-6c54-4151-bd25-526b85db298d.png)    


    ![image](https://user-images.githubusercontent.com/69157076/173504921-abd5519f-0eb6-4c15-b00b-50892148f75a.png)
    
- 만약 시간 복잡도 함수가 2n^2 + 3n 이면?
  - 가장 높은 차수는 2n^2
  - 상수는 실제 큰 영향이 없음
  - 결국 빅 오 표기법으로는 O(n^2) 즉, 식에서 가장 큰 차수만 생각!!
    
